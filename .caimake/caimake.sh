#!/bin/bash

# ===============================================================
# This file was autogenerated. Do not edit it manually!
# ===============================================================

# Exit on error. Append "|| true" if you expect an error.
set -o errexit
# Do not allow use of undefined vars. Use ${VAR:-} to use an undefined VAR
set -o nounset
# Catch the error in pipeline.
set -o pipefail

VERBOSE="${VERBOSE:-1}"

# Exit on error. Append "|| true" if you expect an error.
# Do not allow use of undefined vars. Use ${VAR:-} to use an undefined VAR
# Catch the error in pipeline.

# The root of the build/dist directory
# make-rules should be palced in project/hack/
# so the project root is project/hack/make-rules/lib/../../../
PRJ_ROOT="$(pwd -P)"
# PRJ_ROOT="$(cd "$(dirname "${BASH_SOURCE}")/../../.." && pwd -P)"
PRJ_CMDPATH="${PRJ_ROOT}/cmd"
PRJ_OUTPUT_BINPATH="${PRJ_ROOT}/bin"

GO_ONBUILD_IMAGE="${GO_ONBUILD_IMAGE:-golang:1.9.2-alpine3.6}"


util::parse_args() {
	local arg
	for arg in $@; do
		if [[ "${arg}" == -* ]]; then
			# Assume arguments starting with a dash are flags to pass to go.
			flags+=("${arg}")
		else
			targets+=("${arg}")
		fi
	done
}

# util::split slices input string into all substrings separated by sep
util::split() {
	local IN=$1
	local IFS=$2

	# $IN and $IFS should not be empty
	[[ -n ${IN} && -n ${IFS} ]] || {
		echo ${IN}
		return
	}

	IFS=${IFS} read -ra tokens <<<"$IN"
	echo ${tokens[@]}
}

# Returns go package of this project 
# the project must be palced in GOPATH
util::get_go_package() {
	local gopaths=($(util::split "${GOPATH:-}" ":"))
	[[ -n ${gopaths:-} ]] || {
		log::error_exit "!!! No GOPATH set in env"
	}

	local pkg=${PRJ_ROOT}

	for gopath in ${gopaths[@]}; do
		# delete gopath in pkg
		local gosrc="${gopath%/}/src/"
		pkg=${pkg#${gosrc}}
	done

	# delete last "/" in path
	pkg=${pkg%/}
	echo ${pkg}
}

# This figures out the host platform without relying on golang.  We need this as
# we don't want a golang install to be a prerequisite to building yet we need
# this info to figure out where the final binaries are placed.
util::host_platform() {
	local host_os
	local host_arch
	case "$(uname -s)" in
		Darwin)
			host_os=darwin
			;;
		Linux)
			host_os=linux
			;;
		*)
			log::error "Unsupported host OS.  Must be Linux or Mac OS X."
			exit 1
			;;
	esac

	case "$(uname -m)" in
		x86_64*)
			host_arch=amd64
			;;
		i?86_64*)
			host_arch=amd64
			;;
		amd64*)
			host_arch=amd64
			;;
		aarch64*)
			host_arch=arm64
			;;
		arm64*)
			host_arch=arm64
			;;
		arm*)
			host_arch=arm
			;;
		i?86*)
			host_arch=x86
			;;
		s390x*)
			host_arch=s390x
			;;
		ppc64le*)
			host_arch=ppc64le
			;;
		*)
			log::error "Unsupported host arch. Must be x86_64, 386, arm, arm64, s390x or ppc64le."
			exit 1
			;;
	esac
	echo "${host_os}/${host_arch}"
}

# Controls verbosity of the script output and logging.
VERBOSE="${VERBOSE:-5}"

# If set true, the log will be colorized
readonly COLOR_LOG=${COLOR_LOG:-true}

if [[ ${COLOR_LOG} == "true" ]]; then
	readonly blue="\033[34m"
	readonly green="\033[32m"
	readonly red="\033[31m"
	readonly yellow="\033[36m"
	readonly strong="\033[1m"
	readonly reset="\033[0m"
else
	readonly blue=""
	readonly green=""
	readonly red=""
	readonly yellow=""
	readonly strong=""
	readonly reset=""
fi

# Handler for when we exit automatically on an error.
# Borrowed from https://gist.github.com/ahendrix/7030300
log::errexit() {
	local err="${PIPESTATUS[@]}"

	# If the shell we are in doesn't have errexit set (common in subshells) then
	# don't dump stacks.
	set +o | grep -qe "-o errexit" || return

	set +o xtrace
	local code="${1:-1}"
	# Print out the stack trace described by $function_stack  
	if [ ${#FUNCNAME[@]} -gt 2 ]; then
		log::error "Call tree:"
		for ((i = 1; i < ${#FUNCNAME[@]} - 1; i++)); do
			log::error " $i: ${BASH_SOURCE[$i+1]}:${BASH_LINENO[$i]} ${FUNCNAME[$i]}(...)"
		done
	fi
	log::error_exit "Error in ${BASH_SOURCE[1]}:${BASH_LINENO[0]}. '${BASH_COMMAND}' exited with status $err" "${1:-1}" 1
}

log::install_errexit() {
	# trap ERR to provide an error handler whenever a command exits nonzero  this
	# is a more verbose version of set -o errexit
	trap 'log::errexit' ERR

	# setting errtrace allows our ERR trap handler to be propagated to functions,
	# expansions and subshells
	set -o errtrace
}

# Print out the stack trace
#
# Args:
#   $1 The number of stack frames to skip when printing.
log::stack() {
	local stack_skip=${1:-0}
	stack_skip=$((stack_skip + 1))
	if [[ ${#FUNCNAME[@]} -gt $stack_skip ]]; then
		echo -e "${strong}Call stack:${reset}" >&2
		local i
		for ((i = 1; i <= ${#FUNCNAME[@]} - $stack_skip; i++)); do
			local frame_no=$((i - 1 + stack_skip))
			local source_file=${BASH_SOURCE[$frame_no]}
			local source_lineno=${BASH_LINENO[$((frame_no - 1))]}
			local funcname=${FUNCNAME[$frame_no]}
			echo -e "${strong}  $i: ${source_file}:${source_lineno} ${funcname}(...)${reset}" >&2
		done
	fi
}

# Log an error and exit.
# Args:
#   $1 Message to log with the error
#   $2 The error code to return
#   $3 The number of stack frames to skip when printing.
log::error_exit() {
	local message="${1:-}"
	local code="${2:-1}"
	local stack_skip="${3:-0}"
	stack_skip=$((stack_skip + 1))

	if [[ ${VERBOSE} -ge 4 ]]; then
		local source_file=${BASH_SOURCE[$stack_skip]}
		local source_line=${BASH_LINENO[$((stack_skip - 1))]}
		echo -e "${red}!!!${reset} ${strong}Error in ${source_file}:${source_line}${reset}" >&2
		[[ -z ${1-} ]] || {
			echo -e "${strong}  ${1}${reset}" >&2
		}

		log::stack $stack_skip

		echo "Exiting with status ${code}" >&2
	fi

	exit "${code}"
}

# Log an error but keep going.  Don't dump the stack or exit.
log::error() {
	timestamp=$(date +"[%m%d %H:%M:%S]")
	echo -e "${red}!!! $timestamp${reset} ${strong}${1-}${reset}" >&2
	shift
	for message; do
		echo "    $message" >&2
	done
}

# Print an usage message to stderr.  The arguments are printed directly.
log::usage() {
	echo >&2
	local message
	for message; do
		echo "$message" >&2
	done
	echo >&2
}

log::usage_from_stdin() {
	local messages=()
	while read -r line; do
		messages+=("$line")
	done

	log::usage "${messages[@]}"
}

# Print out some info that isn't a top level status line
log::info() {
	local V="${V:-0}"
	if [[ $VERBOSE < $V ]]; then
		return
	fi

	for message; do
		echo -e "${strong}$message${reset}"
	done
}

# Just like log::info, but no \n, so you can make a progress bar
log::progress() {
	for message; do
		echo -e -n "$message"
	done
}

log::info_from_stdin() {
	local messages=()
	while read -r line; do
		messages+=("$line")
	done

	log::info "${messages[@]}"
}

# Print a status line.  Formatted to show up in a stream of output.
log::status() {
	local V="${V:-0}"
	if [[ $VERBOSE < $V ]]; then
		return
	fi

	timestamp=$(date +"[%m%d %H:%M:%S]")
	echo -e "${blue}==> $timestamp${reset} ${strong}$1${reset}"
	shift
	for message; do
		echo "    $message"
	done
}

log::confirm() {
	local message=${1:-Are you sure?}
	echo -e "${green}${message}${reset}"

	while true; do
		read -p "[y/n]: " -n 1 -r
		if [[ ${REPLY} =~ ^[Yy]$ ]]; then
			echo
			return 0
		fi
		if [[ ${REPLY} =~ ^[Nn]$ ]]; then
			echo
			return 1
		fi
		echo -e "\n${red}invalid input ${REPLY}${reset}"
	done
}

log::install_errexit


# -----------------------------------------------------------------------------
# Version management helpers.  These functions help to set, save and load the
# following variables:
#
#    PRJ_GIT_COMMIT - The git commit id corresponding to this
#          source code.
#    PRJ_GIT_TREE_STATE - "clean" indicates no changes since the git commit id
#        "dirty" indicates source code changes after the git commit id
#        "archive" indicates the tree was produced by 'git archive'
#    PRJ_GIT_VERSION - "vX.Y" used to indicate the last release version.
#    PRJ_GIT_REMOTE - The git remote origin url.

# Grovels through git to set a set of env variables.
#
# If PRJ_GIT_VERSION_FILE, this function will load from that file instead of
# querying git.
version::get_version_vars() {
	if [[ -n ${PRJ_GIT_VERSION_FILE-} ]]; then
		version::load_version_vars "${PRJ_GIT_VERSION_FILE}"
		return
	fi

	# If the project source was exported through git archive, then
	# we likely don't have a git tree, but these magic values may be filled in.
	if [[ '$Format:%%$' == "%" ]]; then
		PRJ_GIT_COMMIT='$Format:%H$'
		PRJ_GIT_TREE_STATE="archive"
		# When a 'git archive' is exported, the '$Format:%D$' below will look
		# something like 'HEAD -> release-1.8, tag: v1.8.3' where then 'tag: '
		# can be extracted from it.
		if [[ '$Format:%D$' =~ "tag:\ (v[^ ]+)" ]]; then
			PRJ_GIT_VERSION="${BASH_REMATCH[1]}"
		fi
	fi

	local git=(git --work-tree "${PRJ_ROOT}")

	if [[ -z ${PRJ_GIT_REMOTE-} ]]; then
		PRJ_GIT_REMOTE="$("${git[@]}" remote get-url origin 2>/dev/null)"
	fi

	if [[ -n ${PRJ_GIT_COMMIT-} ]] || PRJ_GIT_COMMIT=$("${git[@]}" rev-parse "HEAD^{commit}" 2>/dev/null); then
		if [[ -z ${PRJ_GIT_TREE_STATE-} ]]; then
			# Check if the tree is dirty.  default to dirty
			if git_status=$("${git[@]}" status --porcelain 2>/dev/null) && [[ -z ${git_status} ]]; then
				PRJ_GIT_TREE_STATE="clean"
			else
				PRJ_GIT_TREE_STATE="dirty"
			fi
		fi

		# Use git describe to find the version based on annotated tags.
		if [[ -n ${PRJ_GIT_VERSION-} ]] || PRJ_GIT_VERSION=$("${git[@]}" describe --tags --abbrev=14 "${PRJ_GIT_COMMIT}^{commit}" 2>/dev/null); then
			# '+' can not be used in docker tag
			PRJ_DOCKER_TAG=${PRJ_GIT_VERSION}
			# This translates the "git describe" to an actual semver.org
			# compatible semantic version that looks something like this:
			#   v1.1.0-alpha.0.6+84c76d1142ea4d
			#
			# TODO: We continue calling this "git version" because so many
			# downstream consumers are expecting it there.
			DASHES_IN_VERSION=$(echo "${PRJ_GIT_VERSION}" | sed "s/[^-]//g")
			if [[ "${DASHES_IN_VERSION}" == "---" ]]; then
				# We have distance to subversion (v1.1.0-subversion-1-gCommitHash)
				PRJ_GIT_VERSION=$(echo "${PRJ_GIT_VERSION}" | sed "s/-\([0-9]\{1,\}\)-g\([0-9a-f]\{14\}\)$/.\1\+\2/")
				PRJ_DOCKER_TAG=$(echo "${PRJ_DOCKER_TAG}" | sed "s/-\([0-9]\{1,\}\)-g\([0-9a-f]\{14\}\)$/.\1\-\2/")
			elif [[ "${DASHES_IN_VERSION}" == "--" ]]; then
				# We have distance to base tag (v1.1.0-1-gCommitHash)
				PRJ_GIT_VERSION=$(echo "${PRJ_GIT_VERSION}" | sed "s/-g\([0-9a-f]\{14\}\)$/+\1/")
				PRJ_DOCKER_TAG=$(echo "${PRJ_DOCKER_TAG}" | sed "s/-g\([0-9a-f]\{14\}\)$/-\1/")
			fi

		fi

		# no tags found
		if [[ -z ${PRJ_GIT_VERSION-} ]]; then
			PRJ_GIT_VERSION="v0.0.0"
			PRJ_DOCKER_TAG="v0.0.0"
		fi

		# alias VERSION to PRJ_GIT_VERSION
		if [[ -n ${VERSION-} ]]; then
			PRJ_GIT_VERSION=${VERSION}
			PRJ_DOCKER_TAG=${VERSION}
		fi

		if [[ "${PRJ_GIT_TREE_STATE}" == "dirty" ]]; then
			# git describe --dirty only considers changes to existing files, but
			# that is problematic since new untracked .go files affect the build,
			# so use our idea of "dirty" from git status instead.
			PRJ_GIT_VERSION+="-dirty"
			PRJ_DOCKER_TAG+="-dirty"
		fi
	fi
}

# Saves the environment flags to $1
version::save_version_vars() {
	local version_file=${1-}
	[[ -n ${version_file} ]] || {
		echo "!!! Internal error.  No file specified in version::save_version_vars"
		return 1
	}

	cat <<EOF >"${version_file}"
PRJ_GIT_COMMIT='${PRJ_GIT_COMMIT-}'
PRJ_GIT_TREE_STATE='${PRJ_GIT_TREE_STATE-}'
PRJ_GIT_VERSION='${PRJ_GIT_VERSION-}'
PRJ_GIT_REMOTE='${PRJ_GIT_REMOTE}'
EOF
}

# Loads up the version variables from file $1
version::load_version_vars() {
	local version_file=${1-}
	[[ -n ${version_file} ]] || {
		echo "!!! Internal error.  No file specified in version::load_version_vars"
		return 1
	}

	source "${version_file}"
}

version::ldflag() {
	local key=${1}
	local val=${2}

	# If you update these, also update the list pkg/version/def.bzl.
	echo "-X ${GO_PACKAGE}/pkg/version.${key}=${val}"
}

# Prints the value that needs to be passed to the -ldflags parameter of go build
# in order to set the project based on the git tree status.
# IMPORTANT: if you update any of these, also update the lists in
# pkg/version/def.bzl and hack/print-workspace-status.sh.
version::ldflags() {
	version::get_version_vars
	local buildDate=
	[[ -z ${SOURCE_DATE_EPOCH-} ]] || buildDate="--date=@${SOURCE_DATE_EPOCH}"
	local -a ldflags=($(version::ldflag "buildDate" "$(date ${buildDate} -u +'%Y-%m-%dT%H:%M:%SZ')"))
	if [[ -n ${PRJ_GIT_COMMIT-} ]]; then
		ldflags+=($(version::ldflag "gitCommit" "${PRJ_GIT_COMMIT}"))
		ldflags+=($(version::ldflag "gitTreeState" "${PRJ_GIT_TREE_STATE}"))
	fi

	if [[ -n ${PRJ_GIT_VERSION-} ]]; then
		ldflags+=($(version::ldflag "version" "${PRJ_GIT_VERSION}"))
	fi

	if [[ -n ${PRJ_GIT_REMOTE-} ]]; then
		ldflags+=($(version::ldflag "gitRemote" "${PRJ_GIT_REMOTE}"))
	fi

	# The -ldflags parameter takes a single string, so join the output.
	echo "${ldflags[*]-}"
}

# options in this scripts
# LOCAL_BUILD: If set, built on localhost. Otherwise, built in docker.
# GO_BUILD_TARGETS: Incoming variable of targets to build for.
# GO_STATIC_LIBRARIES: Incoming variable of static targets to build for. If set, 
#     the targets will be built with CGO_ENABLED=0.
# GO_BUILD_PLATFORMS: Incoming variable of targets platforms to build for.  If unset
#     then just the host architecture is built.
# GO_FASTBUILD: If set to "true", a few of architechtrues are built. .e.g linux/amd64.

# =========================================================
# update the following variables based on your project.
# =========================================================
# targets on cmd
readonly GO_BUILD_TARGETS=(
	${GO_BUILD_TARGETS[@]-}
)

# static libraries
readonly GO_STATIC_LIBRARIES=(
	${GO_STATIC_LIBRARIES[@]:-}
)

# Gigabytes desired for parallel platform builds. 11 is fairly
# arbitrary, but is a reasonable splitting point for 2015
# laptops-versus-not.
readonly GO_PARALLEL_BUILD_MEMORY=${GO_PARALLEL_BUILD_MEMORY:-4}

# The golang package that we are building.
readonly GO_PACKAGE=${GO_PACKAGE:-$(util::get_go_package)}

# supported minimum go version 
readonly MINIMUM_GO_VERSION=${MINIMUM_GO_VERSION:-"go1.8.0"}

# =========================================================
# set up targets binaries platforms
# =========================================================
readonly GO_BUILD_BINARIES=("${GO_BUILD_TARGETS[@]##*/}")

if [[ -n "${GO_BUILD_PLATFORMS:-}" ]]; then
	readonly GO_BUILD_PLATFORMS=(${GO_BUILD_PLATFORMS[@]})
elif [[ "${GO_FASTBUILD:-}" == "true" ]]; then
	readonly GO_BUILD_PLATFORMS=(linux/amd64)
else
	readonly GO_BUILD_PLATFORMS=(
		linux/amd64
		darwin/amd64
	)
fi

readonly GO_ALL_BUILD_TARGETS=(
	"${GO_BUILD_TARGETS[@]-}"
)

readonly GO_ALL_BUILD_BINARIES=(
	"${GO_ALL_BUILD_TARGETS[@]##*/}"
)

# the following directories will not be tested
readonly GO_NOTEST=(
	vendor
	test
	tests
	scripts
	hack
)

# =========================================================
# functions
# =========================================================

golang::is_statically_linked_library() {
	local e
	for e in "${GO_STATIC_LIBRARIES[@]-}"; do [[ "$1" == *"/$e" ]] && return 0; done
	# Allow individual overrides--e.g., so that you can get a static build 
	# for inclusion in a container.
	if [ -n "${GO_STATIC_OVERRIDES:+x}" ]; then
		for e in "${GO_STATIC_OVERRIDES[@]}"; do [[ "$1" == *"/$e" ]] && return 0; done
	fi
	return 1
}

# golang::binaries_from_targets take a list of build targets and return the
# full go package to be built
golang::binaries_from_targets() {
	local target
	for target; do
		# If the target starts with what looks like a domain name, assume it has a
		# fully-qualified package name rather than one that needs the Kubernetes
		# package prepended.
		if [[ "${target}" =~ ^([[:alnum:]]+".")+[[:alnum:]]+"/" ]]; then
			echo "${target}"
		else
			echo "${GO_PACKAGE}/${target}"
		fi
	done
}

# Asks golang what it thinks the host platform is. The go tool chain does some
# slightly different things when the target platform matches the host platform.
golang::host_platform() {
	echo "$(go env GOHOSTOS)/$(go env GOHOSTARCH)"
}

# Takes the platform name ($1) and sets the appropriate golang env variables
# for that platform.
golang::set_platform_envs() {
	[[ -n ${1-} ]] || {
		log::error_exit "!!! Internal error. No platform set in golang::set_platform_envs"
	}

	export GOOS=${platform%/*}
	export GOARCH=${platform##*/}
	export CGO_ENABLED=${CGO_ENABLED:-}

	# Do not set CC when building natively on a platform, only if cross-compiling from linux/amd64
	if [[ $(golang::host_platform) == "linux/amd64" ]]; then
		# Dynamic CGO linking for other server architectures than linux/amd64 goes here
		# If you want to include support for more server platforms than these, add arch-specific gcc names here
		case "${platform}" in
			"linux/arm")
				export CGO_ENABLED=1
				export CC=arm-linux-gnueabihf-gcc
				;;
			"linux/arm64")
				export CGO_ENABLED=1
				export CC=aarch64-linux-gnu-gcc
				;;
			"linux/ppc64le")
				export CGO_ENABLED=1
				export CC=powerpc64le-linux-gnu-gcc
				;;
			"linux/s390x")
				export CGO_ENABLED=1
				export CC=s390x-linux-gnu-gcc
				;;
		esac
	fi
}

golang::unset_platform_envs() {
	unset GOOS
	unset GOARCH
	unset GOROOT
	unset CGO_ENABLED
	unset CC
}

# Ensure the go tool exists and is a viable version.
golang::verify_go_version() {
	if [[ -z "$(which go)" ]]; then
		log::usage_from_stdin <<EOF
Can't find 'go' in PATH, please fix and retry.
See http://golang.org/doc/install for installation instructions.
EOF
		return 2
	fi

	local go_version
	go_version=($(go version))
	local minimum_go_version
	minimum_go_version=${MINIMUM_GO_VERSION}
	if [[ "${minimum_go_version}" != $(echo -e "${minimum_go_version}\n${go_version[2]}" | sort -s -t. -k 1,1 -k 2,2n -k 3,3n | head -n1) && "${go_version[2]}" != "devel" ]]; then
		log::usage_from_stdin <<EOF
Detected go version: ${go_version[*]}.
This project requires ${minimum_go_version} or greater.
Please install ${minimum_go_version} or later.
EOF
		return 2
	fi
}

# golang::setup_env will check that the `go` commands is available in
# ${PATH}. It will also check that the Go version is good enough for the
# Kubernetes build.
#
# Inputs:
#   EXTRA_GOPATH - If set, this is included in created GOPATH
#
# Outputs:
#   env-var GOPATH points to our local output dir
#   env-var GOBIN is unset (we want binaries in a predictable place)
#   env-var GO15VENDOREXPERIMENT=1
#   current directory is within GOPATH
golang::setup_env() {
	golang::verify_go_version

	# Append EXTRA_GOPATH to the GOPATH if it is defined.
	if [[ -n ${EXTRA_GOPATH:-} ]]; then
		export GOPATH="${GOPATH}:${EXTRA_GOPATH}"
	fi

	# Assume that we are now within the GOPATH

	# Set GOROOT so binaries that parse code can work properly.
	export GOROOT=$(go env GOROOT)

	# Unset GOBIN in case it already exists in the current session.
	unset GOBIN

	# This seems to matter to some tools (godep, ginkgo...)
	export GO15VENDOREXPERIMENT=1
}

golang::recognize_gopath() {
	local gopaths=($(util::split "${GOPATH:-}" ":"))
	[[ -n ${gopaths:-} ]] || {
		log::error_exit "!!! No GOPATH set in env"
	}

	local pkg=${PRJ_ROOT}

	for gopath in ${gopaths[@]}; do
		# delete gopath in pkg
		local gosrc="${gopath%/}/src/"
		if [[ "${pkg}" =~ ${gosrc} ]]; then
			echo ${gopath%/}
			return
		fi
	done

	log::error_exit "!!! No GOPATH matches this project"
}

# This will take binaries from $GOPATH/bin and copy them to the appropriate
# place in ${GO_OUTPUT_BINDIR}
#
# Ideally this wouldn't be necessary and we could just set GOBIN to
# GO_OUTPUT_BINDIR but that won't work in the face of cross compilation.  'go
# install' will place binaries that match the host platform directly in $GOBIN
# while placing cross compiled binaries into `platform_arch` subdirs.  This
# complicates pretty much everything else we do around packaging and such.
golang::place_bins() {
	local host_platform
	host_platform=$(golang::host_platform)

	V=2 log::status "Placing binaries"
	local gopath="$(golang::recognize_gopath)"
	local platform
	for platform in "${GO_BUILD_PLATFORMS[@]}"; do
		# The substitution on platform_src below will replace all slashes with
		# underscores.  It'll transform darwin/amd64 -> darwin_amd64.
		local platform_src="${platform//\//_}"
		if [[ $platform == $host_platform ]]; then
			# rm -f "${THIS_PLATFORM_BIN}"
			log::status "Linking" "${PRJ_OUTPUT_BINPATH}/${platform_src}/*" "->" "${PRJ_OUTPUT_BINPATH}/*"
			ln -sf ${PRJ_OUTPUT_BINPATH}/${platform_src}/* "${PRJ_OUTPUT_BINPATH}"
			log::status "Copying" "${PRJ_OUTPUT_BINPATH}/${platform_src}/*" "->" "${gopath}/bin/"
			cp ${PRJ_OUTPUT_BINPATH}/${platform_src}/* ${gopath}/bin/
		fi

		# optional: place binaries on gopath/bin/GOOS/GOARCH
		# local full_binpath_src="${gopath}/bin/${platform_src}"
		# if [[ -d "${full_binpath_src}" ]]; then
		# 	mkdir -p "${PRJ_OUTPUT_BINPATH}/${platform}"
		# 	find "${full_binpath_src}" -maxdepth 1 -type f -exec \
		# 		rsync -pc {} "${PRJ_OUTPUT_BINPATH}/${platform}" \;
		# fi
	done
}

golang::fallback_if_stdlib_not_installable() {
	local go_root_dir=$(go env GOROOT)
	local go_host_os=$(go env GOHOSTOS)
	local go_host_arch=$(go env GOHOSTARCH)
	local cgo_pkg_dir=${go_root_dir}/pkg/${go_host_os}_${go_host_arch}_cgo

	if [ -e ${cgo_pkg_dir} ]; then
		return 0
	fi

	if [ -w ${go_root_dir}/pkg ]; then
		return 0
	fi

	log::status "+++ Warning: stdlib pkg with cgo flag not found."
	log::status "+++ Warning: stdlib pkg cannot be rebuilt since ${go_root_dir}/pkg is not writable by $(whoami)"
	log::status "+++ Warning: Make ${go_root_dir}/pkg writable for $(whoami) for a one-time stdlib install, Or"
	log::status "+++ Warning: Rebuild stdlib using the command 'CGO_ENABLED=0 go install -a -installsuffix cgo std'"
	log::status "+++ Falling back to go build, which is slower"

	local_build=true
}

# Try and replicate the native binary placement of go install without
# calling go install.
golang::output_filename_for_binary() {
	local binary=$1
	local platform=$2
	local output_path="${PRJ_OUTPUT_BINPATH}"
	# place binary in palce like project_root/bin/darwin_amd64
	output_path="${output_path}/${platform//\//_}"

	local bin=$(basename "${binary}")
	if [[ ${GOOS} == "windows" ]]; then
		bin="${bin}.exe"
	fi
	echo "${output_path}/${bin}"
}

golang::build_binaries_for_platform() {
	local platform=$1
	local local_build=${2-}

	local -a statics=()
	local -a nonstatics=()
	local -a tests=()

	V=2 log::info "Env for ${platform}: GOOS=${GOOS-} GOARCH=${GOARCH-} GOROOT=${GOROOT-} CGO_ENABLED=${CGO_ENABLED-} CC=${CC-}"

	for binary in "${binaries[@]}"; do
		if [[ "${binary}" =~ ".test"$ ]]; then
			tests+=($binary)
		elif golang::is_statically_linked_library "${binary}"; then
			statics+=($binary)
		else
			nonstatics+=($binary)
		fi
	done

	if [[ "${#statics[@]}" != 0 ]]; then
		golang::fallback_if_stdlib_not_installable
	fi

	if [[ "${local_build:-}" == "true" ]]; then
		# use local go build
		for test in "${tests[@]:+${tests[@]}}"; do
			local outfile=$(golang::output_filename_for_binary "${test}" "${platform}")
			local testpkg="$(dirname ${test})"
			go test -i -c \
				"${goflags[@]:+${goflags[@]}}" \
				-gcflags "${gogcflags}" \
				-ldflags "${goldflags}" \
				-o "${outfile}" \
				"${testpkg}"
		done

		log::progress "    "
		for binary in "${statics[@]:+${statics[@]}}"; do
			local outfile=$(golang::output_filename_for_binary "${binary}" "${platform}")
			CGO_ENABLED=0 go build -i -o "${outfile}" \
				"${goflags[@]:+${goflags[@]}}" \
				-gcflags "${gogcflags}" \
				-ldflags "${goldflags}" \
				"${binary}"
			log::progress "*"
		done
		for binary in "${nonstatics[@]:+${nonstatics[@]}}"; do
			local outfile=$(golang::output_filename_for_binary "${binary}" "${platform}")
			go build -i -o "${outfile}" \
				"${goflags[@]:+${goflags[@]}}" \
				-gcflags "${gogcflags}" \
				-ldflags "${goldflags}" \
				"${binary}"
			log::progress "*"
		done
		log::progress "\n"
	else
		# use docker build
		for test in "${tests[@]:+${tests[@]}}"; do
			local outfile=$(golang::output_filename_for_binary "${test}" "${platform}")
			local testpkg="$(dirname ${test})"
			docker run --rm \
				-v ${PRJ_ROOT}:${PRJ_ROOT} \
				-w ${PRJ_ROOT} \
				-e GOOS=${GOOS} \
				-e GOARCH=${GOARCH} \
				-e GOPATH=${GOPATH} \
				-e CGO_ENABLED=${CGO_ENABLED} \
				${GO_ONBUILD_IMAGE} \
				go test -i -c -o "${outfile}" \
				"${goflags[@]:+${goflags[@]}}" \
				-gcflags "${gogcflags}" \
				-ldflags "${goldflags}" \
				"${testpkg}"
		done

		log::progress "    "
		for binary in "${statics[@]:+${statics[@]}}"; do
			local outfile=$(golang::output_filename_for_binary "${binary}" "${platform}")
			docker run --rm \
				-v ${PRJ_ROOT}:${PRJ_ROOT} \
				-w ${PRJ_ROOT} \
				-e GOOS=${GOOS} \
				-e GOARCH=${GOARCH} \
				-e GOPATH=${GOPATH} \
				-e CGO_ENABLED=0 \
				${GO_ONBUILD_IMAGE} \
				go build -o "${outfile}" \
				"${goflags[@]:+${goflags[@]}}" \
				-gcflags "${gogcflags}" \
				-ldflags "${goldflags}" \
				"${binary}"
			log::progress "*"
		done
		for binary in "${nonstatics[@]:+${nonstatics[@]}}"; do
			local outfile=$(golang::output_filename_for_binary "${binary}" "${platform}")
			docker run --rm \
				-v ${PRJ_ROOT}:${PRJ_ROOT} \
				-w ${PRJ_ROOT} \
				-e GOOS=${GOOS} \
				-e GOARCH=${GOARCH} \
				-e GOPATH=${GOPATH} \
				-e CGO_ENABLED=${CGO_ENABLED} \
				${GO_ONBUILD_IMAGE} \
				go build -o "${outfile}" \
				"${goflags[@]:+${goflags[@]}}" \
				-gcflags "${gogcflags}" \
				-ldflags "${goldflags}" \
				"${binary}"
			log::progress "*"
		done
		log::progress "\n"
	fi

}

# Return approximate physical memory available in gigabytes.
golang::get_physmem() {
	local mem

	case "$(go env GOHOSTOS)" in
		"linux")
			# Linux kernel version >=3.14, in kb
			if mem=$(grep MemAvailable /proc/meminfo | awk '{ print $2 }'); then
				echo $((${mem} / 1048576))
				return
			fi

			# Linux, in kb
			if mem=$(grep MemTotal /proc/meminfo | awk '{ print $2 }'); then
				echo $((${mem} / 1048576))
				return
			fi
			;;
		"darwin")
			# OS X, in bytes. Note that get_physmem, as used, should only ever
			# run in a Linux container (because it's only used in the multiple
			# platform case, which is a Dockerized build), but this is provided
			# for completeness.
			if mem=$(sysctl -n hw.memsize 2>/dev/null); then
				echo $((${mem} / 1073741824))
				return
			fi
			;;
	esac

	# If we can't infer it, just give up and assume a low memory system
	echo 1
}

# Build binaries targets specified
#
# Input:
#   $@ - targets and go flags.  If no targets are set then all binaries targets
#     are built.
#   GO_BUILD_PLATFORMS - Incoming variable of targets to build for.  If unset
#     then just the host architecture is built.
golang::build_binaries() {
	# Create a sub-shell so that we don't pollute the outer environment
	(
		# Check for `go` binary and set ${GOPATH}.
		golang::setup_env
		V=2 log::info "Go version: $(go version)"

		local local_build=${LOCAL_BUILD-}

		local host_platform
		host_platform=$(golang::host_platform)

		# Use eval to preserve embedded quoted strings.
		local goflags goldflags gogcflags
		eval "goflags=(${GOFLAGS:-})"
		goldflags="${GOLDFLAGS:-} $(version::ldflags)"
		gogcflags="${GOGCFLAGS:-}"

		util::parse_args "$@"
		local -a targets=(${targets[@]-})
		goflags+=(${flags[@]-})

		if [[ ${#targets[@]} -eq 0 ]]; then
			targets=("${GO_ALL_BUILD_TARGETS[@]}")
		fi

		local -a platforms=(${GO_BUILD_PLATFORMS[@]-})
		if [[ ${#platforms[@]} -eq 0 ]]; then
			platforms=("${host_platform}")
		fi

		local binaries
		binaries=($(golang::binaries_from_targets "${targets[@]}"))

		local parallel=false
		if [[ ${#platforms[@]} -gt 1 ]]; then
			local gigs
			gigs=$(golang::get_physmem)

			if [[ ${gigs} -ge ${GO_PARALLEL_BUILD_MEMORY} ]]; then
				log::status "Multiple platforms requested and available ${gigs}G >= threshold ${GO_PARALLEL_BUILD_MEMORY}G, building platforms in parallel"
				parallel=true
			else
				log::status "Multiple platforms requested, but available ${gigs}G < threshold ${GO_PARALLEL_BUILD_MEMORY}G, building platforms in serial"
				parallel=false
			fi
		fi

		local build_on="in Docker [${GO_ONBUILD_IMAGE}]"
		if [[ ${local_build:-} == "true" ]]; then
			build_on="on localhost [${host_platform}]"
		fi

		if [[ "${parallel}" == "true" ]]; then
			log::status "Building environment:" "${build_on}"
			log::status "Building go targets for {${platforms[*]}} in parallel (output will appear in a burst when complete):" "${targets[@]}"
			local platform
			for platform in "${platforms[@]}"; do (
				golang::set_platform_envs "${platform}"
				log::status "${platform}: go build started"
				golang::build_binaries_for_platform ${platform} ${local_build:-}
				log::status "${platform}: go build finished"
			) &>"/tmp//${platform//\//_}.build" &
			done

			local fails=0
			for job in $(jobs -p); do
				wait ${job} || let "fails+=1"
			done

			for platform in "${platforms[@]}"; do
				cat "/tmp//${platform//\//_}.build"
			done

			exit ${fails}
		else
			for platform in "${platforms[@]}"; do
				log::status "Building environment:" "${build_on}"
				log::status "Building go targets for ${platform}:" "${targets[@]}"
				(
					golang::set_platform_envs "${platform}"
					golang::build_binaries_for_platform ${platform} ${local_build:-}
				)
			done
		fi
	)
}

golang::filter_tests() {
	local -a IN=($1)
	local -a exceptions=($2)
	for pkg in "${IN[@]}"; do
		local skip=
		for exception in "${exceptions[@]}"; do
			if [[ "${pkg}" =~ /${exception}(/?|$) ]]; then
				skip="true"
				break
			fi
		done

		if [[ ${skip} != "true" ]]; then
			echo "${pkg}"
		fi
	done

}

# Test all pkg except vendor, test, tests, scripts, hack
#
# Input:
#   $@ - go flags. 
#   GO_BUILD_PLATFORMS - Incoming variable of targets to build for.  If unset
#     then just the host architecture is built.
#   GO_TEST_EXCEPTIONS - Incoming variable of pkgs to test for.  If unset
#     then all pkgs are tested.
golang::unittest() {
	# Create a sub-shell so that we don't pollute the outer environment
	(
		# Check for `go` binary and set ${GOPATH}.
		golang::setup_env
		V=2 log::info "Go version: $(go version)"

		local local_build=${LOCAL_BUILD-}

		local host_platform
		host_platform=$(golang::host_platform)

		# Use eval to preserve embedded quoted strings.
		local goflags goldflags gogcflags
		eval "goflags=(${GOFLAGS:-})"
		goldflags="${GOLDFLAGS:-} $(version::ldflags)"
		gogcflags="${GOGCFLAGS:-}"

		util::parse_args "$@"
		goflags+=(${flags[@]-})

		local -a targets=($(go list ./...))
		local -a exceptions=(${GO_NOTEST[@]-})
		exceptions+=(${GO_TEST_EXCEPTIONS[@]-})

		# NOTE: Using "${array[*]}" here is correct.  [@] becomes distinct words (in
		# bash parlance).
		targets=($(golang::filter_tests "${targets[*]}" "${exceptions[*]}"))
		# add .test suffix
		targets=(${targets[@]/%/\/unittest.test})

		local binaries
		binaries=($(golang::binaries_from_targets "${targets[@]}"))

		local -a platforms=(${GO_BUILD_PLATFORMS[@]-})
		if [[ ${#platforms[@]} -eq 0 ]]; then
			platforms=("${host_platform}")
		fi

		local build_on="in Docker [${GO_ONBUILD_IMAGE}]"
		if [[ ${local_build:-} == "true" ]]; then
			build_on="on localhost [${host_platform}]"
		fi

		for platform in "${platforms[@]}"; do
			log::status "Testing environment:" "${build_on}"
			log::status "Testing go targets for ${platform}:" "${targets[@]}"
			(
				golang::set_platform_envs "${platform}"
				golang::build_binaries_for_platform ${platform} ${local_build:-}
			)
		done
	)
}

# =========================================================
# update the following variables based on your project.
# =========================================================
# multiple registries for docker push
readonly DOCKER_REGISTRIES=(
	${DOCKER_REGISTRIES[@]-}
)

# docker build targets 
readonly DOCKER_BUILD_TARGETS=(
	${DOCKER_BUILD_TARGETS[@]-}
)

# Container image prefix and suffix added to targets.
# The final built images are:
#   $[REGISTRY]/$[DOCKER_IMAGE_PREFIX]$[TARGET]$[DOCKER_IMAGE_SUFFIX]:$[VERSION]
#   $[REGISTRY] is an item from $[DOCKER_REGISTRIES], $[TARGET] is the basename from $[DOCKER_BUILD_TARGETS[@]].
readonly DOCKER_IMAGE_PREFIX=${DOCKER_IMAGE_PREFIX:-}
readonly DOCKER_IMAGE_SUFFIX=${DOCKER_IMAGE_SUFFIX:-}

# If not true, scripts will check whether image exists in remote registry.
readonly DOCKER_FORCE_PUSH=${DOCKER_FORCE_PUSH:-false}

# =========================================================
# functions
# =========================================================

docker::names_from_targets() {
	local target
	for target; do
		# get base name of target
		echo "${DOCKER_IMAGE_PREFIX}${target##*/}${DOCKER_IMAGE_SUFFIX}" | tr -d " "
	done
}

docker::dockerfiles_from_targets() {
	local target
	for target; do
		echo "${PRJ_ROOT}/${target}/Dockerfile"
	done
}

docker::build_images() {
	# Create a sub-shell so that we don't pollute the outer environment
	(
		version::get_version_vars
		local tag=${PRJ_DOCKER_TAG:-dirty}

		util::parse_args "$@"
		local -a targets=(${targets[@]-})
		if [[ ${#targets[@]} -eq 0 ]]; then
			targets=("${DOCKER_BUILD_TARGETS[@]}")
		fi

		length=${#targets[@]}

		local -a names
		names=($(docker::names_from_targets "${targets[@]}"))

		local -a dockerfiles
		dockerfiles=($(docker::dockerfiles_from_targets "${targets[@]}"))

		for ((i = 0; i < ${length}; i++)); do
			local dockerfile="${dockerfiles[$i]}"
			local name="${names[$i]}"
			# TODO use tmp dir 
			log::status "Building docker image for ${name}:${tag}"
			docker build -f "${dockerfile}" -t "${name}:${tag}" ${PRJ_ROOT}

			for registry in "${DOCKER_REGISTRIES[@]}"; do
				log::status "Tagging docker image ${name}:${tag} to ${registry}/${name}:${tag}"
				docker tag "${name}:${tag}" "${registry}/${name}:${tag}"
			done

			# untag temporary docker image
			docker rmi "${name}:${tag}"
		done
	)
}

docker::push_images() {
	# Create a sub-shell so that we don't pollute the outer environment
	(
		version::get_version_vars
		local tag=${PRJ_DOCKER_TAG:-dirty}

		util::parse_args "$@"
		local -a targets=(${targets[@]-})
		if [[ ${#targets[@]} -eq 0 ]]; then
			targets=("${DOCKER_BUILD_TARGETS[@]}")
		fi

		length=${#targets[@]}

		local names
		names=($(docker::names_from_targets "${targets[@]}"))

		for ((i = 0; i < ${length}; i++)); do
			local name="${names[$i]}"
			for registry in "${DOCKER_REGISTRIES[@]}"; do
				if [[ ${DOCKER_FORCE_PUSH-} != "true" ]]; then
					if docker::is_image_exists_in_registry ${registry} ${name} ${tag}; then
						if ! log::confirm "Docker image [${registry}/${name}:${tag}] already exists in the remote registry.\nDo you want to override it?"; then
							continue
						fi
					fi
				fi
				log::status "Pushing docker image ${registry}/${name}:${tag}"
				docker push "${registry}/${name}:${tag}"
			done
		done
	)
}

docker::index_server() {
	local domain="${1%%/*}"
	echo "https://${domain}/v2/"
}

docker::get_auth_server() {
	local index_server=$1
	auth=$(curl -s -D - ${index_server} | grep Www-Authenticate | cut -d " " -f 3)
	# delete white space
	auth="${auth//[[:space:]]/}"
	# auth: realm="https://auth.docker.io/token",service="registry.docker.io"
	tokens=($(util::split "${auth}" ","))
	for token in "${tokens[@]}"; do
		eval ${token}
	done

}

# docker::get_bearer_token returns a bearer token of registry with scope pull
docker::get_bearer_token() {
	local index_server="$1"
	local repo="$2"

	docker::get_auth_server "${index_server}"

	local url="${realm}?scope=repository:${repo}:pull&service=${service}&client_id=make"

	V=2 log::status "get token from url ${url}"

	token="$(curl -s ${url} | jq ".token" | tr -d \")"
}

# docker::get_manifest takes three parameters, 
# index_server: https://cargo.caicloudprivatest.com/v2/
# repo: caicloud/admin
# tag: v0.1.0
docker::get_manifest() {
	local index_server=$1
	local repo=$2
	local tag=$3
	local token=$4

	local url="${index_server}/${repo}/manifests/${tag}"
	errors=$(curl -s -H "Authorization: Bearer ${token}" ${url} | jq ".errors")
	echo errors
}

docker::is_image_exists_in_registry() {
	local registry=$1
	local name=$2
	local tag=$3

	local index_server="$(docker::index_server ${registry})"
	local repo="${registry#*/}/${name}"

	docker::get_bearer_token "${index_server}" "${repo}"
	local url="${index_server}${repo}/manifests/${tag}"

	error_code=$(curl -s -H "Authorization: Bearer ${token}" ${url} | jq ".errors | .[0] | .code")

	if [[ ${error_code-} == "null" ]]; then
		# found: no error
		return 0
	elif [[ "${error_code-}" == "\"MANIFEST_UNKNWN\"" ]]; then
		# not found
		return 1
	else
		log::error_exit "Unexcepted error occurs when getting manifest of image ${registry}/${name}/${tag}"
	fi
}

PRJ_OUTPUT_HOSTBIN="${PRJ_OUTPUT_BINPATH}/$(util::host_platform)"

entry::clean() {
	rm -rf ${PRJ_OUTPUT_BINPATH}
}

entry::go::usage() {
	log::usage_from_stdin <<EOF
usage: $(basename $0) go <commands> [TARGETS]

Available Commands:
    build      build go package
    unittest   test all package in this project
EOF
}

entry::go::build() {
	golang::build_binaries "$@"
	golang::place_bins
}

entry::go::unittest() {
	golang::unittest "$@"
}

entry::go() {
	subcommand=${1-}
	case $subcommand in
		"" | "-h" | "--help")
			entry::go::usage
			;;
		*)
			shift
			entry::go::${subcommand} $@
			;;
	esac

}

entry::docker::build() {
	docker::build_images "$@"
}

entry::docker::push() {
	docker::push_images "$@"
}

entry::docker::usage() {
	log::usage_from_stdin <<EOF
usage: $(basename $0) docker <commands> [TARGETS]

Available Commands:
    build      build docker image
    push       push docker image to registries
EOF
}

entry::docker() {
	subcommand=${1-}
	case $subcommand in
		"" | "-h" | "--help")
			entry::docker::usage
			;;
		*)
			shift
			entry::docker::${subcommand} $@
			;;
	esac
}

usage() {
	log::usage_from_stdin <<EOF
usage: caimake <commands> <subcommands>

Available Commands:
    clean      clean all build output
    go         building for golang
	docker     building for docker 
EOF
}

subcommand=${1-}
case $subcommand in
	"" | "-h" | "--help")
		usage
		;;
	"clean")
		shift
		entry::clean $@
		;;
	"go")
		shift
		entry::go $@
		;;
	"docker")
		shift
		entry::docker $@
		;;
	*)
		usage
		;;
esac
